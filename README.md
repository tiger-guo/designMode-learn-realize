## OO 原则

- 封装变化
- 多用组合，少用继承
- 针对接口编程，不针对实现编程
- 为交互对象之间松耦合设计而努力
- 类应该对扩展开放，对修改关闭
- 依赖抽象，不要依赖具体类
## 设计模式已完成内容
### 代理模式：
1. 定义：

    为另一个对象提供一个替身或占位符以访问这个对象。

2. 静态代理 

    代理对象继承代理类的父接口并提前声明将要代理类的父接口，通过构造方法将被代理对象传入，在代理类中调用被代理的对象的方法进行执行。
3. 动态代理
    
    ① JDK自带动态代理
        
        public interface InvocationHandler {
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
        }
            - proxy：被代理的类的实例
            - method：调用被代理的类的方法
            - args：该方法需要的参数
        public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h) throws IllegalArgumentException
            - loader：被代理的类的类加载器
            - interfaces：被代理类的接口数组
            - invocationHandler：就是实现了InvocationHandler的处理器类
    ② CGLIB方法
    
        CGLIB方法实现比较简单，仅需要实现 MethodInterceptor 接口，传入代理对象即可。 
     
### 策略模式
1. 定义：
   
   定义算法簇，分别封装起来，让它们直接可以相互替换，此模式让算法的变化独立于使用算法的客户。
   
### 观察者模式
1. 定义：

    定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到消息并自动更新。
    
### 装饰者模式
1. 定义：
    
    动态的将职责附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。   
    
### 工厂方法模式
1. 定义：
    
    定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

### 抽象工厂模式
1. 定义:

    提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
    
### 单件模式
1. 定义：

    确保一个类只有一个实例，并提供一个全局访问点。    
    
### 命令模式
1. 定义：

    将“请求”封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。命令模式也支持撤销的操作。

### 适配器模式：
1. 定义：

    将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
        
### 外观模式：
1. 定义：

    提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。
    
### 模板方法模式：
1. 定义：

    在一个方法中定义一个算法的框架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
    
### 迭代器模式：
1. 定义;

    提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

### 组合模式：
1. 定义：
    
    允许你将对象组合成树形结构来表现 “整体/部分” 层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

### 状态模式：
1. 定义：

    允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。

### 复合模式：
1. 定义：

    复合模式结合两个或以上的模式，组合成一个解决方案，解决一再发生的一般性问题。